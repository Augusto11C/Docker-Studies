Github search keyword : `id "com.bmuschko.docker-java-application"`

## TODO
- Find tutorial CI/CD -> Commit Github repo executes several tests (unit and integration test) and update docker image if everything goes well

## Tutorials
- [X] [Dockerizing your Spring Boot applications](https://www.callicoder.com/spring-boot-docker-example/)

- [How to create a custom Docker image with JDK8, Maven and Gradle](https://medium.com/@migueldoctor/how-to-create-a-custom-docker-image-with-jdk8-maven-and-gradle-ddc90f41cee4)

- [Automating Docker Builds With Gradle](https://tomgregory.com/automating-docker-builds-with-gradle/) [NEXT]

- [Simple automate build using Docker and Gradle for Java Spring Boot project](https://medium.com/@engleangs/simple-automate-build-using-docker-and-gradle-for-java-spring-boot-project-70d79e65b4e6)

- [ Docker for Spring boot | Gradle | Java micro service](https://medium.com/@sairamkrish/docker-for-spring-boot-gradle-java-micro-service-done-the-right-way-2f46231dbc06)

- [Spring Boot in a Container](https://github.com/spring-guides/top-spring-boot-docker#a-better-dockerfile)

--- 

- [Spring Boot, Mysql, React docker compose example](https://www.callicoder.com/spring-boot-mysql-react-docker-compose-example/)

- [Building a Spring Boot application in Jenkins (part 1 of microservice devops series)](https://tomgregory.com/building-a-spring-boot-application-in-jenkins/)

- [Building a Spring Boot application in Docker and Jenkins (part 2 of microservice devops series)](https://tomgregory.com/building-a-spring-boot-application-in-docker-and-jenkins/)

- [Dockerizando um ambiente com APIâ€™s springboot se comunicando por RabbitMQ](https://medium.com/totvsdevelopers/dockerizando-um-ambiente-com-apis-springboot-se-comunicando-por-rabbitmq-c8368faa6e64)

- [Spring Boot Docker Integration With Rabbitmq and Mysql](https://www.codeprimers.com/spring-boot-docker-integration-with-rabbitmq-and-mysql/)

## Gradle

- https://github.com/whitingjr/echo-api/blob/b73cfd308db5dc61131381a6a71a537397e92dc9/build.gradle

- https://github.com/pedro-n-rocha/micro-container/blob/1c8339f13a1c3f7cfd664566e8abf625585dda03/build.gradle

- https://github.com/set321go/profiles-service/blob/be7fed98e5b384f0727afa3b1a44b2056f7b26ba/build.gradle

- https://github.com/Alxandr/ircbot/blob/7fdb23da2ac12f6eb9bd69ef1c12ff217242f540/build.gradle

- https://github.com/kvrobert/TLOGRS/blob/2a718278a02db754e041921574962eb8aefeb8ee/build%20(1).gradle

- https://github.com/mrdunski/soccero-panda-manta/blob/e1826352b0d582dbc5961acde7135b6bc5506ade/build.gradle

## Options to build and Run SpringBoot Application
1. Use a readily available gradle image and build the application. Then build a Docker image with the output artifact (jar)
2. Have a multi-stage Dockerfile. As a first stage, build the application, in the second stage, build a docker image with output artifact from previous stage.
	-  [Getting from the local computer](https://medium.com/@sairamkrish/docker-for-spring-boot-gradle-java-micro-service-done-the-right-way-2f46231dbc06)
	- [Download from github](https://medium.com/@engleangs/simple-automate-build-using-docker-and-gradle-for-java-spring-boot-project-70d79e65b4e6)
3. Use plugins to run 


## Docker Image + JAR
```
# Start with a base image containing Java runtime
FROM openjdk:8-jdk-alpine

# Add Maintainer Info
LABEL maintainer="augusto.calado11@gmail.com"

# Add a volume pointing to /tmp
VOLUME /tmp

# Make port 8080 available to the world outside this container
EXPOSE 8080

# The application's jar file
# # TODO
ARG JAR_FILE=target/websocket-demo-0.0.1-SNAPSHOT.jar

# Add the application's jar to the container
ADD ${JAR_FILE} websocket-demo.jar

# Run the jar file 
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/websocket-demo.jar"]
```

**Things About Dockerfile **
- **VOLUME**: Volumes are a mechanism to persist data generated by the container on the Host OS, and share directories from the Host OS with the container. The `VOLUME` instruction creates a mount point on the container with the specified path.
	When running the container, it is possible to specify the directory on the **Hot OS** to which the given mount point will be mapped to. After that, anything that the container writes to the mounted path is written to the mapped directory on the Host OS.

- ARG: The ARG instruction defines a variable with a default value. You can override the default value of the variable by passing it at build time.

	`ARG <name>[=<default value>]`

- **ENTRYPOINT**: This is where you configure how the application is executed inside the container.

### Generating Docker Image
```
docker build -d -t spring-boot-websocket-chat-demo .
// use the -d option in docker run command to run the container in the background

docker run -p 5000:8080 spring-boot-websocket-chat-demo

// access it at `http://localhost:5000`
```

### Tagging and Publishing the Image
```bash
// Tag
// docker tag image username/repository:tag
docker tag spring-boot-websocket-chat-demo augustocalado11/spring-boot-websocket-chat-demo:0.0.1-SNAPSHOT

// Publish
docker push augustocalado11/spring-boot-websocket-chat-demo:0.0.1-SNAPSHOT
``` 
### Pulling the Image from Dockerhub and Running 
```
docker run -p 5000:8080 augustocalado11/spring-boot-websocket-chat-demo:0.0.1-SNAPSHOT
```

## Automating the Docker Image Creation and Publishing Using
