Github search keyword : `id "com.bmuschko.docker-java-application"`

## TODO
- Find tutorial CI/CD -> Commit Github repo executes several tests (unit and integration test) and update docker image if everything goes well

## Tutorials
- [X] [Dockerizing your Spring Boot applications](https://www.callicoder.com/spring-boot-docker-example/)

- [How to create a custom Docker image with JDK8, Maven and Gradle](https://medium.com/@migueldoctor/how-to-create-a-custom-docker-image-with-jdk8-maven-and-gradle-ddc90f41cee4)

- [Automating Docker Builds With Gradle](https://tomgregory.com/automating-docker-builds-with-gradle/) [NEXT]

- [Simple automate build using Docker and Gradle for Java Spring Boot project](https://medium.com/@engleangs/simple-automate-build-using-docker-and-gradle-for-java-spring-boot-project-70d79e65b4e6)

- [ Docker for Spring boot | Gradle | Java micro service](https://medium.com/@sairamkrish/docker-for-spring-boot-gradle-java-micro-service-done-the-right-way-2f46231dbc06)

- [Spring Boot in a Container](https://github.com/spring-guides/top-spring-boot-docker#a-better-dockerfile)

--- 

- [Spring Boot, Mysql, React docker compose example](https://www.callicoder.com/spring-boot-mysql-react-docker-compose-example/)

- [Building a Spring Boot application in Jenkins (part 1 of microservice devops series)](https://tomgregory.com/building-a-spring-boot-application-in-jenkins/)

- [Building a Spring Boot application in Docker and Jenkins (part 2 of microservice devops series)](https://tomgregory.com/building-a-spring-boot-application-in-docker-and-jenkins/)

- [Dockerizando um ambiente com APIâ€™s springboot se comunicando por RabbitMQ](https://medium.com/totvsdevelopers/dockerizando-um-ambiente-com-apis-springboot-se-comunicando-por-rabbitmq-c8368faa6e64)

- [Spring Boot Docker Integration With Rabbitmq and Mysql](https://www.codeprimers.com/spring-boot-docker-integration-with-rabbitmq-and-mysql/)

## Gradle

- https://github.com/whitingjr/echo-api/blob/b73cfd308db5dc61131381a6a71a537397e92dc9/build.gradle

- https://github.com/pedro-n-rocha/micro-container/blob/1c8339f13a1c3f7cfd664566e8abf625585dda03/build.gradle

- https://github.com/set321go/profiles-service/blob/be7fed98e5b384f0727afa3b1a44b2056f7b26ba/build.gradle

- https://github.com/Alxandr/ircbot/blob/7fdb23da2ac12f6eb9bd69ef1c12ff217242f540/build.gradle

- https://github.com/kvrobert/TLOGRS/blob/2a718278a02db754e041921574962eb8aefeb8ee/build%20(1).gradle

- https://github.com/mrdunski/soccero-panda-manta/blob/e1826352b0d582dbc5961acde7135b6bc5506ade/build.gradle

## Options to build and Run SpringBoot Application
1. Use a readily available gradle image and build the application. Then build a Docker image with the output artifact (jar)
2. Have a multi-stage Dockerfile. As a first stage, build the application, in the second stage, build a docker image with output artifact from previous stage.
	-  [Getting from the local computer](https://medium.com/@sairamkrish/docker-for-spring-boot-gradle-java-micro-service-done-the-right-way-2f46231dbc06)
	- [Download from github](https://medium.com/@engleangs/simple-automate-build-using-docker-and-gradle-for-java-spring-boot-project-70d79e65b4e6)
3. Use plugins to run 


## Docker Image Made up with JAR - [WAY I] App Build Locally (Traditional)
```
# Start with a base image containing Java runtime
FROM openjdk:8-jdk-alpine

# Add Maintainer Info
LABEL maintainer="augusto.calado11@gmail.com"

# Add a volume pointing to /tmp
VOLUME /tmp

# Make port 8080 available to the world outside this container
EXPOSE 8080

# The application's jar file
# # TODO
ARG JAR_FILE=target/websocket-demo-0.0.1-SNAPSHOT.jar

# Add the application's jar to the container
ADD ${JAR_FILE} websocket-demo.jar

# Run the jar file 
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/websocket-demo.jar"]
```

**Things About Dockerfile **
- **VOLUME**: Volumes are a mechanism to persist data generated by the container on the Host OS, and share directories from the Host OS with the container. The `VOLUME` instruction creates a mount point on the container with the specified path.
	When running the container, it is possible to specify the directory on the **Hot OS** to which the given mount point will be mapped to. After that, anything that the container writes to the mounted path is written to the mapped directory on the Host OS.

- ARG: The ARG instruction defines a variable with a default value. You can override the default value of the variable by passing it at build time.

	`ARG <name>[=<default value>]`

- **ENTRYPOINT**: This is where you configure how the application is executed inside the container.

### Generating Docker Image
```
docker build -d -t spring-boot-websocket-chat-demo .
// use the -d option in docker run command to run the container in the background

docker run -p 5000:8080 spring-boot-websocket-chat-demo

// access it at `http://localhost:5000`
```

### Tagging and Publishing the Image
```bash
// Tag
// docker tag image username/repository:tag
docker tag spring-boot-websocket-chat-demo augustocalado11/spring-boot-websocket-chat-demo:0.0.1-SNAPSHOT

// Publish
docker push augustocalado11/spring-boot-websocket-chat-demo:0.0.1-SNAPSHOT
``` 
### Pulling the Image from Dockerhub and Running 
```
docker run -p 5000:8080 augustocalado11/spring-boot-websocket-chat-demo:0.0.1-SNAPSHOT
```

## Docker Image Made up with JAR - [WAY II] App Build in Container (Performatic Gradle Cache - Using Cache from Host)
Use a readily available gradle image and build the application. Then build a Docker image with the output artifact (jar)

- [Docker-gradle](https://hub.docker.com/_/gradle/) is a ready to use docker image with gradle 
- Build the application inside the container
	- Map 
- Map a volume in the container in order to retrive the JAR file
- Create a image with the JAR file

```
docker volume create --name gradle-cache

docker run --rm -v gradle-cache:/home/gradle/.gradle -v "$PWD":/home/gradle/project -w /home/gradle/project gradle:4.7.0-jdk8-alpine gradle build

docker run --rm \
  --name gradletest \
  --mount type=volume,source=gradle-cache,target=/home/gradle/.gradle \
  --mount type=bind,source="$PWD",target=/home/gradle/project \
  -w /home/gradle/project \
  gradle:6.6.1-jdk8 gradle build

ls -ltrh ./build/libs
```

## Docker Image Made up with JAR - [WAY III] (Multi-stage approach)

There is no way to mount a volume at the image build time. But it is possible to introduce new stage that will download all dependencies and will be cached as Docker image layer.

As a best practice, we would like to download the dependencies first before building the code. This will speed up the subsequent build flow, since the layer is already cached. It gets tricky to achieve this with Gradle. I have explained this in detail below.

```
FROM gradle:5.6.4-jdk11 as cache
RUN mkdir -p /home/gradle/cache_home
ENV GRADLE_USER_HOME /home/gradle/cache_home
COPY build.gradle /home/gradle/java-code/
WORKDIR /home/gradle/java-code
RUN gradle clean build -i --stacktrace

FROM gradle:5.6.4-jdk11 as builder
COPY --from=cache /home/gradle/cache_home /home/gradle/.gradle
COPY . /usr/src/java-code/
WORKDIR /usr/src/java-code
RUN gradle bootJar -i --stacktrace

FROM openjdk:11-jre-slim
EXPOSE 8080
USER root
WORKDIR /usr/src/java-app
COPY --from=builder /usr/src/java-code/build/libs/*.jar ./app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]
```

- The stage `cache` will be rebuilt only when `build.gradle` is changed.
- n the `builder` stage Gradle cache is copied to avoid downloading the dependencies again: `COPY --from=cache /home/gradle/cache_home /home/gradle/.gradle`.

## Automating the Docker Image Creation and Publishing Using

## Jib - Containerize your Gradle Java project
[Jib GitHub](https://github.com/GoogleContainerTools/jib/tree/master/jib-gradle-plugin#quickstart)

## References
- [Slow gradle build in Docker. Caching gradle build](https://stackoverflow.com/questions/58593661/slow-gradle-build-in-docker-caching-gradle-build)
